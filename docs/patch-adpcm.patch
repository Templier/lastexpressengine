Index: adpcm.cpp
===================================================================
--- adpcm.cpp	(revision 51749)
+++ adpcm.cpp	(working copy)
@@ -290,8 +290,8 @@
 
 class MSIma_ADPCMStream : public Ima_ADPCMStream {
 public:
-	MSIma_ADPCMStream(Common::SeekableReadStream *stream, DisposeAfterUse::Flag disposeAfterUse, uint32 size, int rate, int channels, uint32 blockAlign)
-		: Ima_ADPCMStream(stream, disposeAfterUse, size, rate, channels, blockAlign) {
+	MSIma_ADPCMStream(Common::SeekableReadStream *stream, DisposeAfterUse::Flag disposeAfterUse, uint32 size, int rate, int channels, uint32 blockAlign, bool invertSamples = false)
+		: Ima_ADPCMStream(stream, disposeAfterUse, size, rate, channels, blockAlign), _invertSamples(invertSamples) {
 		if (blockAlign == 0)
 			error("ADPCMStream(): blockAlign isn't specified for MS IMA ADPCM");
 	}
@@ -305,6 +305,9 @@
 
 	int readBufferMSIMA1(int16 *buffer, const int numSamples);
 	int readBufferMSIMA2(int16 *buffer, const int numSamples);
+
+private:
+	bool _invertSamples;    // Some implementations invert the way samples are decoded
 };
 
 int MSIma_ADPCMStream::readBufferMSIMA1(int16 *buffer, const int numSamples) {
@@ -324,8 +327,8 @@
 		for (; samples < numSamples && _blockPos[0] < _blockAlign && !_stream->eos() && _stream->pos() < _endpos; samples += 2) {
 			data = _stream->readByte();
 			_blockPos[0]++;
-			buffer[samples] = decodeIMA(data & 0x0f);
-			buffer[samples + 1] = decodeIMA((data >> 4) & 0x0f);
+			buffer[samples] = decodeIMA(_invertSamples ? (data >> 4) & 0x0f : data & 0x0f);
+			buffer[samples + 1] = decodeIMA(_invertSamples ? data & 0x0f : (data >> 4) & 0x0f);
 		}
 	}
 	return samples;
@@ -733,6 +736,8 @@
 		return new Oki_ADPCMStream(stream, disposeAfterUse, size, rate, channels, blockAlign);
 	case kADPCMMSIma:
 		return new MSIma_ADPCMStream(stream, disposeAfterUse, size, rate, channels, blockAlign);
+	case kADPCMMSImaInverted:
+		return new MSIma_ADPCMStream(stream, disposeAfterUse, size, rate, channels, blockAlign, true);
 	case kADPCMMS:
 		return new MS_ADPCMStream(stream, disposeAfterUse, size, rate, channels, blockAlign);
 	case kADPCMTinsel4:
Index: adpcm.h
===================================================================
--- adpcm.h	(revision 51749)
+++ adpcm.h	(working copy)
@@ -50,14 +50,15 @@
 // Usually, if the audio stream we're trying to play has the FourCC header
 // string intact, it's easy to discern which encoding is used
 enum typesADPCM {
-	kADPCMOki,		// Dialogic/Oki ADPCM (aka VOX)
-	kADPCMMSIma,	// Microsoft IMA ADPCM
-	kADPCMMS,		// Microsoft ADPCM
-	kADPCMTinsel4,	// 4-bit ADPCM used by the Tinsel engine
-	kADPCMTinsel6,	// 6-bit ADPCM used by the Tinsel engine
-	kADPCMTinsel8,	// 8-bit ADPCM used by the Tinsel engine
-	kADPCMIma,		// Standard IMA ADPCM
-	kADPCMApple		// Apple QuickTime IMA ADPCM
+	kADPCMOki,		      // Dialogic/Oki ADPCM (aka VOX)
+	kADPCMMSIma,	      // Microsoft IMA ADPCM
+	kADPCMMSImaInverted,  // Microsoft IMA ADPCM (with inverted samples)
+	kADPCMMS,		      // Microsoft ADPCM
+	kADPCMTinsel4,	      // 4-bit ADPCM used by the Tinsel engine
+	kADPCMTinsel6,	      // 6-bit ADPCM used by the Tinsel engine
+	kADPCMTinsel8,	      // 8-bit ADPCM used by the Tinsel engine
+	kADPCMIma,		      // Standard IMA ADPCM
+	kADPCMApple		      // Apple QuickTime IMA ADPCM
 };
 
 /**
